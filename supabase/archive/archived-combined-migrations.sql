-- Combined Migrations
-- Generated: 2025-09-30T13:45:45.868Z
-- Auto-generated by: npm run generate-migrations


-- ═══════════════════════════════════════════════════════════
-- Migration: 20250130000002_add_behavioral_signals.sql
-- ═══════════════════════════════════════════════════════════

-- Add behavioral signals tracking to onboarding_answers table
-- This allows us to track HOW users answer questions, not just WHAT they answer

-- Add columns for behavioral tracking
ALTER TABLE onboarding_answers
ADD COLUMN IF NOT EXISTS time_to_answer INTEGER, -- milliseconds
ADD COLUMN IF NOT EXISTS time_on_question INTEGER, -- milliseconds
ADD COLUMN IF NOT EXISTS hovered_tooltip BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS tooltip_hover_duration INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS answer_changes INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS mouse_movements INTEGER DEFAULT 0,
ADD COLUMN IF NOT EXISTS pause_before_answer BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS immediate_edit BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS options_selected INTEGER,
ADD COLUMN IF NOT EXISTS selection_order JSONB;

-- Add columns for behavior analysis results
ALTER TABLE onboarding_answers
ADD COLUMN IF NOT EXISTS behavior_confidence TEXT, -- 'high', 'medium', 'low'
ADD COLUMN IF NOT EXISTS user_state TEXT, -- 'confident', 'thoughtful', 'confused', 'uncertain'
ADD COLUMN IF NOT EXISTS needs_follow_up BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS needs_simplification BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS needs_education BOOLEAN DEFAULT FALSE,
ADD COLUMN IF NOT EXISTS engagement_level TEXT, -- 'high', 'medium', 'low'
ADD COLUMN IF NOT EXISTS inferred_complexity TEXT; -- 'simple', 'moderate', 'complex'

-- Create index on behavioral flags for analytics queries
CREATE INDEX IF NOT EXISTS idx_onboarding_answers_behavior_confidence
ON onboarding_answers(behavior_confidence);

CREATE INDEX IF NOT EXISTS idx_onboarding_answers_user_state
ON onboarding_answers(user_state);

CREATE INDEX IF NOT EXISTS idx_onboarding_answers_needs_follow_up
ON onboarding_answers(needs_follow_up) WHERE needs_follow_up = TRUE;

-- Add comment
COMMENT ON COLUMN onboarding_answers.time_to_answer IS 'Time in milliseconds from question shown to answer submitted';
COMMENT ON COLUMN onboarding_answers.behavior_confidence IS 'AI-analyzed confidence level based on user behavior';
COMMENT ON COLUMN onboarding_answers.user_state IS 'AI-inferred mental state: confident, thoughtful, confused, uncertain';
COMMENT ON COLUMN onboarding_answers.needs_follow_up IS 'AI flag: user showed signs of uncertainty, should ask follow-up question';

-- Mark as applied
INSERT INTO schema_migrations (version) VALUES ('20250130000002_add_behavioral_signals.sql');


-- ═══════════════════════════════════════════════════════════
-- Migration: 20250130000003_add_outcome_learning.sql
-- ═══════════════════════════════════════════════════════════

-- Real-Time Outcome Learning Loop
-- Track user feedback and outcomes to continuously improve recommendations

-- Product recommendations table
CREATE TABLE IF NOT EXISTS product_recommendations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID NOT NULL REFERENCES onboarding_sessions(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  archetype_id TEXT NOT NULL,

  -- Recommended products
  products JSONB NOT NULL, -- Array of {product_id, name, category, confidence_score}

  -- Context at time of recommendation
  user_context JSONB, -- Climate, location, season, device
  user_profile JSONB, -- Answers, archetype signals, behavioral data

  -- Metadata
  recommended_at TIMESTAMPTZ DEFAULT NOW(),

  -- Indexes
  CONSTRAINT fk_session FOREIGN KEY (session_id) REFERENCES onboarding_sessions(id)
);

-- Outcome feedback table
CREATE TABLE IF NOT EXISTS outcome_feedback (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  recommendation_id UUID NOT NULL REFERENCES product_recommendations(id) ON DELETE CASCADE,
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Overall satisfaction
  overall_rating INTEGER CHECK (overall_rating BETWEEN 1 AND 5),
  would_recommend BOOLEAN,

  -- Product-specific feedback
  product_ratings JSONB, -- {product_id: {rating: 1-5, effectiveness: 1-5, texture: 1-5}}

  -- Improvement tracking
  improvements TEXT[], -- ['reduced_oiliness', 'clearer_skin', 'less_redness', etc.]
  concerns_addressed TEXT[], -- Which original concerns were solved
  new_concerns TEXT[], -- Any new issues that arose

  -- Detailed feedback
  what_worked TEXT,
  what_didnt_work TEXT,
  additional_notes TEXT,

  -- Timeline
  weeks_used INTEGER, -- How many weeks they tried the routine
  still_using BOOLEAN DEFAULT TRUE,

  -- Metadata
  submitted_at TIMESTAMPTZ DEFAULT NOW(),
  feedback_prompt_sent_at TIMESTAMPTZ,

  CONSTRAINT fk_recommendation FOREIGN KEY (recommendation_id) REFERENCES product_recommendations(id)
);

-- Learning patterns table (aggregated insights)
CREATE TABLE IF NOT EXISTS learning_patterns (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Pattern identification
  pattern_type TEXT NOT NULL, -- 'product_preference', 'archetype_adjustment', 'context_insight'
  pattern_name TEXT NOT NULL, -- e.g., "oily_humid_gel_preference"

  -- Conditions
  archetype_ids TEXT[],
  context_conditions JSONB, -- {climate: 'hot_humid', device: 'mobile'}
  profile_signals JSONB, -- {oily: true, stressed: true}

  -- Outcome
  recommended_change TEXT NOT NULL, -- What to adjust
  confidence_delta FLOAT, -- How much to adjust confidence scores
  supporting_data_count INTEGER DEFAULT 0, -- How many feedback responses support this

  -- Statistics
  avg_rating FLOAT,
  success_rate FLOAT, -- % of users who reported improvement

  -- Status
  is_active BOOLEAN DEFAULT TRUE,
  applied_to_model BOOLEAN DEFAULT FALSE,

  -- Metadata
  discovered_at TIMESTAMPTZ DEFAULT NOW(),
  last_updated TIMESTAMPTZ DEFAULT NOW()
);

-- Model retraining log
CREATE TABLE IF NOT EXISTS model_retraining_log (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),

  -- Training details
  model_version TEXT NOT NULL,
  training_samples_count INTEGER,
  new_feedback_count INTEGER,
  patterns_applied INTEGER,

  -- Performance metrics
  accuracy_before FLOAT,
  accuracy_after FLOAT,
  improvement_delta FLOAT,

  -- Changes made
  changes_summary JSONB, -- What patterns were integrated

  -- Metadata
  trained_at TIMESTAMPTZ DEFAULT NOW(),
  training_duration_seconds INTEGER
);

-- Indexes for performance
CREATE INDEX IF NOT EXISTS idx_recommendations_session ON product_recommendations(session_id);
CREATE INDEX IF NOT EXISTS idx_recommendations_user ON product_recommendations(user_id);
CREATE INDEX IF NOT EXISTS idx_recommendations_archetype ON product_recommendations(archetype_id);
CREATE INDEX IF NOT EXISTS idx_feedback_recommendation ON outcome_feedback(recommendation_id);
CREATE INDEX IF NOT EXISTS idx_feedback_rating ON outcome_feedback(overall_rating);
CREATE INDEX IF NOT EXISTS idx_feedback_submitted ON outcome_feedback(submitted_at);
CREATE INDEX IF NOT EXISTS idx_patterns_active ON learning_patterns(is_active) WHERE is_active = TRUE;
CREATE INDEX IF NOT EXISTS idx_patterns_type ON learning_patterns(pattern_type);

-- RLS Policies
ALTER TABLE product_recommendations ENABLE ROW LEVEL SECURITY;
ALTER TABLE outcome_feedback ENABLE ROW LEVEL SECURITY;
ALTER TABLE learning_patterns ENABLE ROW LEVEL SECURITY;
ALTER TABLE model_retraining_log ENABLE ROW LEVEL SECURITY;

-- Users can view their own recommendations
CREATE POLICY "Users can view own recommendations"
  ON product_recommendations FOR SELECT
  USING (user_id IS NULL OR user_id = auth.uid());

-- Users can insert their own feedback
CREATE POLICY "Users can insert own feedback"
  ON outcome_feedback FOR INSERT
  WITH CHECK (user_id IS NULL OR user_id = auth.uid());

-- Users can view their own feedback
CREATE POLICY "Users can view own feedback"
  ON outcome_feedback FOR SELECT
  USING (user_id IS NULL OR user_id = auth.uid());

-- Public read access to learning patterns (anonymized insights)
CREATE POLICY "Public can view learning patterns"
  ON learning_patterns FOR SELECT
  USING (TRUE);

-- Public read access to model retraining log
CREATE POLICY "Public can view retraining log"
  ON model_retraining_log FOR SELECT
  USING (TRUE);

-- Comments
COMMENT ON TABLE product_recommendations IS 'Stores all product recommendations made to users';
COMMENT ON TABLE outcome_feedback IS 'User feedback on how well recommendations worked';
COMMENT ON TABLE learning_patterns IS 'Discovered patterns from feedback data for model improvement';
COMMENT ON TABLE model_retraining_log IS 'History of model retraining sessions and improvements';
COMMENT ON COLUMN outcome_feedback.overall_rating IS '1-5 star rating of entire recommendation';
COMMENT ON COLUMN learning_patterns.confidence_delta IS 'How much to adjust ML confidence scores based on this pattern';
COMMENT ON COLUMN learning_patterns.supporting_data_count IS 'Number of feedback responses that support this pattern';

-- Mark as applied
INSERT INTO schema_migrations (version) VALUES ('20250130000003_add_outcome_learning.sql');


-- ═══════════════════════════════════════════════════════════
-- Migration: 20250130000004_add_notifications.sql
-- ═══════════════════════════════════════════════════════════

-- In-App Notification System
-- For feedback prompts and other important notifications

CREATE TABLE IF NOT EXISTS notifications (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  session_id UUID REFERENCES onboarding_sessions(id) ON DELETE CASCADE,

  -- Notification details
  type TEXT NOT NULL, -- 'feedback_prompt', 'update', 'achievement', 'insight'
  title TEXT NOT NULL,
  message TEXT NOT NULL,
  action_url TEXT, -- Where to navigate when clicked
  action_label TEXT, -- Button text (e.g., "Give Feedback")

  -- Related data
  recommendation_id UUID REFERENCES product_recommendations(id) ON DELETE CASCADE,
  metadata JSONB, -- Additional context

  -- Status
  is_read BOOLEAN DEFAULT FALSE,
  is_dismissed BOOLEAN DEFAULT FALSE,
  read_at TIMESTAMPTZ,
  dismissed_at TIMESTAMPTZ,

  -- Priority
  priority TEXT DEFAULT 'normal', -- 'low', 'normal', 'high'
  expires_at TIMESTAMPTZ, -- Auto-dismiss after this date

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Notification schedule (for timing feedback prompts)
CREATE TABLE IF NOT EXISTS notification_schedules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  session_id UUID REFERENCES onboarding_sessions(id) ON DELETE CASCADE,
  recommendation_id UUID REFERENCES product_recommendations(id) ON DELETE CASCADE,

  -- Schedule details
  notification_type TEXT NOT NULL,
  scheduled_for TIMESTAMPTZ NOT NULL,
  sent_at TIMESTAMPTZ,
  notification_id UUID REFERENCES notifications(id) ON DELETE SET NULL,

  -- Status
  status TEXT DEFAULT 'pending', -- 'pending', 'sent', 'cancelled'

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW()
);

-- Indexes
CREATE INDEX IF NOT EXISTS idx_notifications_user ON notifications(user_id);
CREATE INDEX IF NOT EXISTS idx_notifications_session ON notifications(session_id);
CREATE INDEX IF NOT EXISTS idx_notifications_unread ON notifications(user_id, is_read) WHERE is_read = FALSE;
CREATE INDEX IF NOT EXISTS idx_notifications_type ON notifications(type);
CREATE INDEX IF NOT EXISTS idx_notification_schedules_pending ON notification_schedules(scheduled_for, status) WHERE status = 'pending';

-- RLS Policies
ALTER TABLE notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE notification_schedules ENABLE ROW LEVEL SECURITY;

-- Users can view their own notifications
CREATE POLICY "Users can view own notifications"
  ON notifications FOR SELECT
  USING (user_id IS NULL OR user_id = auth.uid());

-- Users can update their own notifications (mark as read/dismissed)
CREATE POLICY "Users can update own notifications"
  ON notifications FOR UPDATE
  USING (user_id IS NULL OR user_id = auth.uid());

-- Service can insert notifications
CREATE POLICY "Service can insert notifications"
  ON notifications FOR INSERT
  WITH CHECK (TRUE);

-- Only service can view/manage schedules
CREATE POLICY "Service can manage schedules"
  ON notification_schedules
  USING (TRUE);

-- Function to auto-create feedback notification schedule
CREATE OR REPLACE FUNCTION create_feedback_schedule()
RETURNS TRIGGER AS $$
BEGIN
  -- Schedule feedback prompt for 2 weeks after recommendation
  INSERT INTO notification_schedules (
    user_id,
    session_id,
    recommendation_id,
    notification_type,
    scheduled_for,
    status
  ) VALUES (
    NEW.user_id,
    NEW.session_id,
    NEW.id,
    'feedback_prompt',
    NOW() + INTERVAL '14 days',
    'pending'
  );

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger to auto-schedule feedback
CREATE TRIGGER trigger_create_feedback_schedule
  AFTER INSERT ON product_recommendations
  FOR EACH ROW
  EXECUTE FUNCTION create_feedback_schedule();

-- Function to mark notification as read
CREATE OR REPLACE FUNCTION mark_notification_read(notification_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE notifications
  SET is_read = TRUE,
      read_at = NOW(),
      updated_at = NOW()
  WHERE id = notification_id;
END;
$$ LANGUAGE plpgsql;

-- Function to dismiss notification
CREATE OR REPLACE FUNCTION dismiss_notification(notification_id UUID)
RETURNS VOID AS $$
BEGIN
  UPDATE notifications
  SET is_dismissed = TRUE,
      dismissed_at = NOW(),
      updated_at = NOW()
  WHERE id = notification_id;
END;
$$ LANGUAGE plpgsql;

-- Comments
COMMENT ON TABLE notifications IS 'In-app notifications for users';
COMMENT ON TABLE notification_schedules IS 'Scheduled notifications (e.g., feedback prompts)';
COMMENT ON COLUMN notifications.type IS 'feedback_prompt, update, achievement, insight';
COMMENT ON COLUMN notifications.priority IS 'low, normal, high - affects display order';
COMMENT ON COLUMN notifications.expires_at IS 'Auto-dismiss notification after this date';

-- Mark as applied
INSERT INTO schema_migrations (version) VALUES ('20250130000004_add_notifications.sql');


-- ═══════════════════════════════════════════════════════════
-- Migration: 20250130000005_add_ai_personalization.sql
-- ═══════════════════════════════════════════════════════════

-- AI Personalization Layer
-- Adds AI learning on top of the 7 archetype foundation

-- User AI adjustments (personalization layer per user)
CREATE TABLE IF NOT EXISTS user_ai_adjustments (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,
  session_id UUID REFERENCES onboarding_sessions(id) ON DELETE CASCADE,

  -- Primary archetype (foundation - never changes without explicit reanalysis)
  primary_archetype TEXT NOT NULL,
  archetype_confidence FLOAT, -- 0.0 to 1.0
  secondary_archetype TEXT, -- For users who are between archetypes
  secondary_confidence FLOAT,

  -- AI-learned adjustments (dynamic, changes with feedback)
  adjustments JSONB DEFAULT '{}', -- {increase_hydration: 0.15, reduce_actives: 0.08, prefer_gel_texture: true}
  learned_patterns TEXT[] DEFAULT '{}', -- ['responds_well_to_niacinamide', 'breakouts_from_coconut_oil']

  -- Confidence & validation
  adjustment_confidence TEXT DEFAULT 'low', -- low, medium, high
  based_on_feedback_count INTEGER DEFAULT 0,

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  last_feedback_at TIMESTAMPTZ,

  -- Ensure one record per user
  UNIQUE(user_id)
);

-- AI product exceptions (products AI recommends outside normal archetype matches)
CREATE TABLE IF NOT EXISTS ai_product_exceptions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Product recommendation
  product_id TEXT NOT NULL,
  product_name TEXT,
  product_category TEXT,

  -- Why AI suggests this
  reason TEXT NOT NULL, -- Human-readable explanation
  pattern_match TEXT, -- Which learned pattern triggered this
  confidence FLOAT, -- 0.0 to 1.0

  -- Validation
  times_recommended INTEGER DEFAULT 0,
  times_accepted INTEGER DEFAULT 0,
  times_rejected INTEGER DEFAULT 0,
  avg_rating FLOAT,

  -- Status
  is_active BOOLEAN DEFAULT TRUE,

  -- Metadata
  created_at TIMESTAMPTZ DEFAULT NOW(),
  last_recommended_at TIMESTAMPTZ
);

-- Add personalization field to product_recommendations
ALTER TABLE product_recommendations
ADD COLUMN IF NOT EXISTS personalization JSONB DEFAULT NULL;

COMMENT ON COLUMN product_recommendations.personalization IS 'AI personalization layer: {adjustments: [], confidence: "high", based_on: "3 feedback cycles", ai_exceptions: [...]}';

-- Indexes
CREATE INDEX IF NOT EXISTS idx_user_adjustments_user ON user_ai_adjustments(user_id);
CREATE INDEX IF NOT EXISTS idx_user_adjustments_archetype ON user_ai_adjustments(primary_archetype);
CREATE INDEX IF NOT EXISTS idx_ai_exceptions_user ON ai_product_exceptions(user_id);
CREATE INDEX IF NOT EXISTS idx_ai_exceptions_product ON ai_product_exceptions(product_id);
CREATE INDEX IF NOT EXISTS idx_ai_exceptions_active ON ai_product_exceptions(is_active) WHERE is_active = TRUE;

-- RLS Policies
ALTER TABLE user_ai_adjustments ENABLE ROW LEVEL SECURITY;
ALTER TABLE ai_product_exceptions ENABLE ROW LEVEL SECURITY;

-- Users can view their own adjustments
CREATE POLICY "Users can view own adjustments"
  ON user_ai_adjustments FOR SELECT
  USING (user_id IS NULL OR user_id = auth.uid());

-- System can insert/update adjustments
CREATE POLICY "System can manage adjustments"
  ON user_ai_adjustments FOR ALL
  USING (TRUE)
  WITH CHECK (TRUE);

-- Users can view their own AI exceptions
CREATE POLICY "Users can view own exceptions"
  ON ai_product_exceptions FOR SELECT
  USING (user_id IS NULL OR user_id = auth.uid());

-- System can manage exceptions
CREATE POLICY "System can manage exceptions"
  ON ai_product_exceptions FOR ALL
  USING (TRUE)
  WITH CHECK (TRUE);

-- Comments
COMMENT ON TABLE user_ai_adjustments IS 'Per-user AI personalization layer on top of archetype foundation';
COMMENT ON TABLE ai_product_exceptions IS 'Products AI recommends outside normal archetype matching';
COMMENT ON COLUMN user_ai_adjustments.primary_archetype IS 'Foundation archetype (1 of 7) - stable';
COMMENT ON COLUMN user_ai_adjustments.adjustments IS 'AI-learned tweaks based on feedback';
COMMENT ON COLUMN user_ai_adjustments.learned_patterns IS 'Ingredient/behavior patterns discovered from user feedback';
COMMENT ON COLUMN ai_product_exceptions.reason IS 'Why AI suggests this product despite archetype mismatch';

-- Function to update user adjustments based on feedback
CREATE OR REPLACE FUNCTION update_user_ai_adjustments()
RETURNS TRIGGER AS $$
BEGIN
  -- When new feedback comes in, trigger should update user adjustments
  -- This will be called by the pattern analysis cron job
  UPDATE user_ai_adjustments
  SET
    updated_at = NOW(),
    last_feedback_at = NEW.submitted_at,
    based_on_feedback_count = based_on_feedback_count + 1
  WHERE user_id = NEW.user_id;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Trigger on feedback submission
CREATE TRIGGER trigger_update_user_adjustments
  AFTER INSERT ON outcome_feedback
  FOR EACH ROW
  EXECUTE FUNCTION update_user_ai_adjustments();

-- Mark as applied
INSERT INTO schema_migrations (version) VALUES ('20250130000005_add_ai_personalization.sql');


-- ═══════════════════════════════════════════════════════════
-- Migration: create_analytics_views.sql
-- ═══════════════════════════════════════════════════════════

-- Analytics Dashboard Database Views
-- Provides aggregated data for dashboard insights

-- ============================================
-- View: Session Statistics
-- ============================================
CREATE OR REPLACE VIEW onboarding_session_stats AS
SELECT
  COUNT(*) as total_sessions,
  COUNT(*) FILTER (WHERE is_complete = true) as completed_sessions,
  COUNT(*) FILTER (WHERE is_complete = false) as incomplete_sessions,
  ROUND(AVG(questions_answered)) as avg_questions_per_session,
  ROUND(AVG(confidence), 2) as avg_confidence,
  ROUND(COUNT(*) FILTER (WHERE is_complete = true)::numeric / NULLIF(COUNT(*), 0) * 100, 2) as completion_rate
FROM onboarding_sessions
WHERE created_at >= NOW() - INTERVAL '30 days';

-- ============================================
-- View: Archetype Distribution
-- ============================================
CREATE OR REPLACE VIEW archetype_distribution AS
SELECT
  final_archetype->>'archetype' as archetype_name,
  final_archetype->>'name' as archetype_display_name,
  final_archetype->>'emoji' as archetype_emoji,
  COUNT(*) as count,
  ROUND(COUNT(*)::numeric / (SELECT COUNT(*) FROM onboarding_sessions WHERE is_complete = true) * 100, 2) as percentage
FROM onboarding_sessions
WHERE is_complete = true
  AND final_archetype IS NOT NULL
  AND created_at >= NOW() - INTERVAL '30 days'
GROUP BY final_archetype->>'archetype', final_archetype->>'name', final_archetype->>'emoji'
ORDER BY count DESC;

-- ============================================
-- View: Question Performance
-- ============================================
CREATE OR REPLACE VIEW question_performance AS
SELECT
  oa.question_id,
  COUNT(DISTINCT oa.session_id) as times_asked,
  ROUND(AVG(oa.answer_order), 2) as avg_position,
  COUNT(DISTINCT oa.session_id)::numeric / (SELECT COUNT(*) FROM onboarding_sessions WHERE is_complete = true) as ask_rate
FROM onboarding_answers oa
JOIN onboarding_sessions os ON oa.session_id = os.id
WHERE os.is_complete = true
  AND os.created_at >= NOW() - INTERVAL '30 days'
GROUP BY oa.question_id
ORDER BY times_asked DESC;

-- ============================================
-- View: Daily Session Trends
-- ============================================
CREATE OR REPLACE VIEW daily_session_trends AS
SELECT
  DATE(created_at) as session_date,
  COUNT(*) as total_sessions,
  COUNT(*) FILTER (WHERE is_complete = true) as completed_sessions,
  ROUND(AVG(questions_answered), 1) as avg_questions,
  ROUND(AVG(confidence), 1) as avg_confidence
FROM onboarding_sessions
WHERE created_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(created_at)
ORDER BY session_date DESC;

-- ============================================
-- View: Completion Time Analysis
-- ============================================
CREATE OR REPLACE VIEW completion_time_analysis AS
SELECT
  EXTRACT(EPOCH FROM (completed_at - started_at)) / 60 as minutes_to_complete,
  questions_answered,
  confidence,
  final_archetype->>'archetype' as archetype
FROM onboarding_sessions
WHERE is_complete = true
  AND completed_at IS NOT NULL
  AND created_at >= NOW() - INTERVAL '30 days'
ORDER BY completed_at DESC;

-- ============================================
-- View: Answer Pattern Analysis
-- ============================================
CREATE OR REPLACE VIEW answer_patterns AS
SELECT
  oa.question_id,
  oa.answer_value->>'id' as answer_id,
  COUNT(*) as selection_count,
  ROUND(COUNT(*)::numeric / (SELECT COUNT(*) FROM onboarding_answers WHERE question_id = oa.question_id) * 100, 2) as selection_percentage
FROM onboarding_answers oa
JOIN onboarding_sessions os ON oa.session_id = os.id
WHERE os.is_complete = true
  AND os.created_at >= NOW() - INTERVAL '30 days'
GROUP BY oa.question_id, oa.answer_value->>'id'
ORDER BY oa.question_id, selection_count DESC;

-- ============================================
-- View: User Retention (Resumed Sessions)
-- ============================================
CREATE OR REPLACE VIEW session_retention AS
SELECT
  DATE(started_at) as start_date,
  COUNT(*) FILTER (WHERE last_updated > started_at + INTERVAL '1 hour' AND is_complete = false) as resumed_count,
  COUNT(*) FILTER (WHERE is_complete = false AND last_updated = started_at) as abandoned_immediately,
  COUNT(*) as total_incomplete
FROM onboarding_sessions
WHERE is_complete = false
  AND started_at >= NOW() - INTERVAL '30 days'
GROUP BY DATE(started_at)
ORDER BY start_date DESC;

-- ============================================
-- Function: Get Analytics Summary
-- ============================================
CREATE OR REPLACE FUNCTION get_analytics_summary(days_back INTEGER DEFAULT 30)
RETURNS JSON AS $$
DECLARE
  result JSON;
BEGIN
  SELECT json_build_object(
    'totalSessions', (SELECT COUNT(*) FROM onboarding_sessions WHERE created_at >= NOW() - (days_back || ' days')::INTERVAL),
    'completedSessions', (SELECT COUNT(*) FROM onboarding_sessions WHERE is_complete = true AND created_at >= NOW() - (days_back || ' days')::INTERVAL),
    'completionRate', (SELECT ROUND(COUNT(*) FILTER (WHERE is_complete = true)::numeric / NULLIF(COUNT(*), 0) * 100, 2) FROM onboarding_sessions WHERE created_at >= NOW() - (days_back || ' days')::INTERVAL),
    'avgQuestionsAsked', (SELECT ROUND(AVG(questions_answered), 1) FROM onboarding_sessions WHERE is_complete = true AND created_at >= NOW() - (days_back || ' days')::INTERVAL),
    'avgConfidence', (SELECT ROUND(AVG(confidence), 1) FROM onboarding_sessions WHERE is_complete = true AND created_at >= NOW() - (days_back || ' days')::INTERVAL),
    'avgCompletionTime', (SELECT ROUND(AVG(EXTRACT(EPOCH FROM (completed_at - started_at)) / 60), 1) FROM onboarding_sessions WHERE is_complete = true AND completed_at IS NOT NULL AND created_at >= NOW() - (days_back || ' days')::INTERVAL),
    'topArchetype', (SELECT final_archetype->>'name' FROM onboarding_sessions WHERE is_complete = true AND final_archetype IS NOT NULL AND created_at >= NOW() - (days_back || ' days')::INTERVAL GROUP BY final_archetype->>'name' ORDER BY COUNT(*) DESC LIMIT 1),
    'mostAskedQuestion', (SELECT question_id FROM onboarding_answers oa JOIN onboarding_sessions os ON oa.session_id = os.id WHERE os.created_at >= NOW() - (days_back || ' days')::INTERVAL GROUP BY question_id ORDER BY COUNT(*) DESC LIMIT 1)
  ) INTO result;

  RETURN result;
END;
$$ LANGUAGE plpgsql;

-- ============================================
-- RLS Policies for Analytics Views
-- ============================================

-- Only allow admin access to analytics
-- (You can modify this based on your admin role setup)
CREATE POLICY "Admin can view analytics" ON onboarding_sessions
  FOR SELECT USING (
    EXISTS (
      SELECT 1 FROM auth.users
      WHERE auth.uid() = id
      -- Add your admin check here, e.g., checking user metadata
      -- AND raw_user_meta_data->>'role' = 'admin'
    )
  );

-- Create indexes for better analytics query performance
CREATE INDEX IF NOT EXISTS idx_sessions_created_at ON onboarding_sessions(created_at);
CREATE INDEX IF NOT EXISTS idx_sessions_archetype ON onboarding_sessions((final_archetype->>'archetype'));
CREATE INDEX IF NOT EXISTS idx_sessions_complete_created ON onboarding_sessions(is_complete, created_at);
CREATE INDEX IF NOT EXISTS idx_answers_created_at ON onboarding_answers(answered_at);

-- Mark as applied
INSERT INTO schema_migrations (version) VALUES ('create_analytics_views.sql');


-- ═══════════════════════════════════════════════════════════
-- Migration: create_onboarding_sessions.sql
-- ═══════════════════════════════════════════════════════════

-- Onboarding Sessions Table
CREATE TABLE IF NOT EXISTS onboarding_sessions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES auth.users(id) ON DELETE CASCADE,

  -- Session state
  current_question_id TEXT,
  questions_answered INTEGER DEFAULT 0,
  is_complete BOOLEAN DEFAULT FALSE,

  -- Tracking
  started_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  last_updated TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  completed_at TIMESTAMP WITH TIME ZONE,

  -- Progress data
  confidence NUMERIC DEFAULT 0,
  estimated_remaining INTEGER,
  top_archetypes TEXT[],

  -- Final result (when complete)
  final_archetype JSONB,

  -- Metadata
  created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  expires_at TIMESTAMP WITH TIME ZONE DEFAULT (NOW() + INTERVAL '7 days')
);

-- Session Answers Table (stores answer history)
CREATE TABLE IF NOT EXISTS onboarding_answers (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  session_id UUID REFERENCES onboarding_sessions(id) ON DELETE CASCADE,

  -- Answer data
  question_id TEXT NOT NULL,
  answer_value JSONB NOT NULL, -- Flexible: single value, multiple values, slider, etc.

  -- Confidence at time of answer
  confidence_after NUMERIC,

  -- Tracking
  answered_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
  answer_order INTEGER, -- Track sequence (for edit/rewind)

  -- Constraints
  UNIQUE(session_id, question_id) -- Can't answer same question twice in one session
);

-- Indexes for performance
CREATE INDEX idx_sessions_user_id ON onboarding_sessions(user_id);
CREATE INDEX idx_sessions_incomplete ON onboarding_sessions(is_complete, last_updated) WHERE is_complete = FALSE;
CREATE INDEX idx_answers_session ON onboarding_answers(session_id, answer_order);

-- Auto-update last_updated timestamp
CREATE OR REPLACE FUNCTION update_session_timestamp()
RETURNS TRIGGER AS $$
BEGIN
  NEW.last_updated = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER update_session_timestamp
BEFORE UPDATE ON onboarding_sessions
FOR EACH ROW
EXECUTE FUNCTION update_session_timestamp();

-- Row Level Security (RLS)
ALTER TABLE onboarding_sessions ENABLE ROW LEVEL SECURITY;
ALTER TABLE onboarding_answers ENABLE ROW LEVEL SECURITY;

-- Users can only see their own sessions
CREATE POLICY "Users can view own sessions"
  ON onboarding_sessions
  FOR SELECT
  USING (auth.uid() = user_id OR user_id IS NULL); -- Allow anonymous sessions

CREATE POLICY "Users can insert own sessions"
  ON onboarding_sessions
  FOR INSERT
  WITH CHECK (auth.uid() = user_id OR user_id IS NULL);

CREATE POLICY "Users can update own sessions"
  ON onboarding_sessions
  FOR UPDATE
  USING (auth.uid() = user_id OR user_id IS NULL);

-- Users can manage their session answers
CREATE POLICY "Users can view own answers"
  ON onboarding_answers
  FOR SELECT
  USING (
    session_id IN (
      SELECT id FROM onboarding_sessions
      WHERE user_id = auth.uid() OR user_id IS NULL
    )
  );

CREATE POLICY "Users can insert own answers"
  ON onboarding_answers
  FOR INSERT
  WITH CHECK (
    session_id IN (
      SELECT id FROM onboarding_sessions
      WHERE user_id = auth.uid() OR user_id IS NULL
    )
  );

CREATE POLICY "Users can update own answers"
  ON onboarding_answers
  FOR UPDATE
  USING (
    session_id IN (
      SELECT id FROM onboarding_sessions
      WHERE user_id = auth.uid() OR user_id IS NULL
    )
  );

-- Cleanup function: Delete expired sessions (run daily via cron)
CREATE OR REPLACE FUNCTION cleanup_expired_sessions()
RETURNS void AS $$
BEGIN
  DELETE FROM onboarding_sessions
  WHERE expires_at < NOW()
    AND is_complete = FALSE;
END;
$$ LANGUAGE plpgsql;

-- Comment for documentation
COMMENT ON TABLE onboarding_sessions IS 'Stores user onboarding session state for resume capability';
COMMENT ON TABLE onboarding_answers IS 'Stores individual answers within each session, allowing edit/rewind functionality';

-- Mark as applied
INSERT INTO schema_migrations (version) VALUES ('create_onboarding_sessions.sql');


-- ═══════════════════════════════════════════════════════════
-- Migration: fix_anonymous_sessions_rls.sql
-- ═══════════════════════════════════════════════════════════

-- Fix RLS policies to properly support anonymous sessions
-- The issue: auth.uid() causes "permission denied" errors when called with anon key

-- Drop existing policies
DROP POLICY IF EXISTS "Users can view own sessions" ON onboarding_sessions;
DROP POLICY IF EXISTS "Users can insert own sessions" ON onboarding_sessions;
DROP POLICY IF EXISTS "Users can update own sessions" ON onboarding_sessions;
DROP POLICY IF EXISTS "Users can view own answers" ON onboarding_answers;
DROP POLICY IF EXISTS "Users can insert own answers" ON onboarding_answers;
DROP POLICY IF EXISTS "Users can update own answers" ON onboarding_answers;

-- Recreate policies with proper NULL handling
-- For anonymous sessions (user_id IS NULL), allow all operations

CREATE POLICY "Users can view own sessions"
  ON onboarding_sessions
  FOR SELECT
  USING (
    user_id IS NULL OR
    (auth.uid() IS NOT NULL AND auth.uid() = user_id)
  );

CREATE POLICY "Users can insert own sessions"
  ON onboarding_sessions
  FOR INSERT
  WITH CHECK (
    user_id IS NULL OR
    (auth.uid() IS NOT NULL AND auth.uid() = user_id)
  );

CREATE POLICY "Users can update own sessions"
  ON onboarding_sessions
  FOR UPDATE
  USING (
    user_id IS NULL OR
    (auth.uid() IS NOT NULL AND auth.uid() = user_id)
  );

CREATE POLICY "Users can view own answers"
  ON onboarding_answers
  FOR SELECT
  USING (
    EXISTS (
      SELECT 1 FROM onboarding_sessions
      WHERE onboarding_sessions.id = session_id
      AND (
        onboarding_sessions.user_id IS NULL OR
        (auth.uid() IS NOT NULL AND auth.uid() = onboarding_sessions.user_id)
      )
    )
  );

CREATE POLICY "Users can insert own answers"
  ON onboarding_answers
  FOR INSERT
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM onboarding_sessions
      WHERE onboarding_sessions.id = session_id
      AND (
        onboarding_sessions.user_id IS NULL OR
        (auth.uid() IS NOT NULL AND auth.uid() = onboarding_sessions.user_id)
      )
    )
  );

CREATE POLICY "Users can update own answers"
  ON onboarding_answers
  FOR UPDATE
  USING (
    EXISTS (
      SELECT 1 FROM onboarding_sessions
      WHERE onboarding_sessions.id = session_id
      AND (
        onboarding_sessions.user_id IS NULL OR
        (auth.uid() IS NOT NULL AND auth.uid() = onboarding_sessions.user_id)
      )
    )
  );

-- Mark as applied
INSERT INTO schema_migrations (version) VALUES ('fix_anonymous_sessions_rls.sql');

